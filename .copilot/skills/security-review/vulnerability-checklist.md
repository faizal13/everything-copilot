# OWASP Top 10 Vulnerability Checklist

## A01: Broken Access Control

**What:** Users acting outside their intended permissions.

**Detect:**
- Missing authorization checks on endpoints
- Direct object references without ownership validation
- CORS misconfiguration allowing unauthorized origins
- Missing function-level access control

**Remediate:**
```js
// BAD: No ownership check
app.get('/api/orders/:id', async (req, res) => {
  const order = await Order.findById(req.params.id);
  res.json(order);
});

// GOOD: Verify ownership
app.get('/api/orders/:id', auth, async (req, res) => {
  const order = await Order.findOne({ _id: req.params.id, userId: req.user.id });
  if (!order) return res.status(404).json({ error: 'Not found' });
  res.json(order);
});
```

## A02: Cryptographic Failures

**Detect:** Weak algorithms (MD5, SHA1 for passwords), plaintext storage, missing TLS.

**Remediate:** Use bcrypt/argon2 for passwords, AES-256-GCM for encryption, TLS 1.2+ for transit.

## A03: Injection

**Detect:** String concatenation in queries, unparameterized SQL, eval/exec usage.

```python
# BAD: SQL injection
cursor.execute(f"SELECT * FROM users WHERE name = '{name}'")

# GOOD: Parameterized
cursor.execute("SELECT * FROM users WHERE name = %s", (name,))
```

**Also covers:** NoSQL injection, OS command injection, LDAP injection, XPath injection.

## A04: Insecure Design

**Detect:** Missing rate limiting, no account lockout, predictable resource IDs, missing threat model.

**Remediate:** Design with security in mind â€” rate limit, use UUIDs, implement account lockout after N failures.

## A05: Security Misconfiguration

**Detect:** Default credentials, verbose error messages in production, unnecessary features enabled, missing security headers.

**Checklist:**
- [ ] Default admin passwords changed
- [ ] Stack traces not exposed in production
- [ ] Directory listing disabled
- [ ] Unnecessary HTTP methods disabled
- [ ] Security headers present (see best-practices.md)

## A06: Vulnerable and Outdated Components

**Detect:** Known CVEs in dependencies. See `dependency-scanning.md` for tooling.

## A07: Identification and Authentication Failures

**Detect:** Weak passwords allowed, missing MFA, session fixation, credential stuffing vulnerability.

**Remediate:** Enforce password policy, implement MFA, regenerate session ID after login, rate limit login attempts.

## A08: Software and Data Integrity Failures

**Detect:** Insecure deserialization, untrusted CI/CD pipelines, unsigned updates.

```python
# BAD: Deserializing untrusted data
data = pickle.loads(user_input)  # Remote code execution risk

# GOOD: Use safe formats
data = json.loads(user_input)  # Can't execute code
```

## A09: Security Logging and Monitoring Failures

**Detect:** No logging of login attempts, no alerting on suspicious activity, logs not centralized.

**Remediate:** Log auth events, failed access attempts, input validation failures. Alert on anomalies. Never log passwords or tokens.

## A10: Server-Side Request Forgery (SSRF)

**Detect:** Server makes requests to user-supplied URLs without validation.

```python
# BAD: SSRF vulnerability
response = requests.get(user_provided_url)

# GOOD: Allowlist domains
ALLOWED_HOSTS = ['api.trusted.com']
parsed = urlparse(user_provided_url)
if parsed.hostname not in ALLOWED_HOSTS:
    raise ValueError("Domain not allowed")
```

## Quick Audit Checklist
- [ ] All endpoints have authorization checks
- [ ] Passwords hashed with bcrypt/argon2 (never MD5/SHA1)
- [ ] All queries parameterized (no string concatenation)
- [ ] Rate limiting on auth endpoints
- [ ] Dependencies scanned for known CVEs
- [ ] No secrets in source code
- [ ] Security headers configured
- [ ] Auth events logged (without sensitive data)
- [ ] SSRF protection on user-supplied URLs
- [ ] Deserialization uses safe formats only
