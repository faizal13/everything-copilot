#!/usr/bin/env node

/**
 * skill-creator.js - Generate skill definitions from git history.
 *
 * Analyses recent commits to extract patterns and generates a new skill
 * directory with SKILL.md manifest and supporting documentation files.
 *
 * Usage:
 *   node scripts/skill-creator.js <skill-name> [--range=HEAD~10..HEAD] [--output=.copilot/skills/]
 */

'use strict';

const fs = require('node:fs');
const path = require('node:path');
const { execSync } = require('node:child_process');
const { log, writeFile, fileExists, getProjectRoot } = require('./lib/utils');

// ---------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------

const VALID_NAME_RE = /^[a-z][a-z0-9-]*$/;

const DEFAULT_RANGE = 'HEAD~20..HEAD';
const DEFAULT_OUTPUT = '.copilot/skills';

// ---------------------------------------------------------------------------
// CLI argument parsing
// ---------------------------------------------------------------------------

function parseArgs(argv) {
  const args = argv.slice(2);
  const opts = { range: DEFAULT_RANGE, output: DEFAULT_OUTPUT, name: null };

  for (const arg of args) {
    if (arg.startsWith('--range=')) {
      opts.range = arg.slice('--range='.length);
    } else if (arg.startsWith('--output=')) {
      opts.output = arg.slice('--output='.length);
    } else if (!arg.startsWith('-')) {
      opts.name = arg;
    }
  }

  return opts;
}

// ---------------------------------------------------------------------------
// Git log parsing
// ---------------------------------------------------------------------------

function parseGitLog(range) {
  try {
    const raw = execSync(`git log --oneline --no-decorate ${range}`, {
      encoding: 'utf8',
      timeout: 10000,
    }).trim();

    if (!raw) return [];

    return raw.split('\n').map((line) => {
      const spaceIdx = line.indexOf(' ');
      const hash = line.slice(0, spaceIdx);
      const message = line.slice(spaceIdx + 1);

      // Detect conventional commit prefix
      const prefixMatch = message.match(/^(feat|fix|refactor|test|docs|chore|style|perf|ci|build)(\(.*?\))?:\s*/i);
      const prefix = prefixMatch ? prefixMatch[1].toLowerCase() : 'other';
      const subject = prefixMatch ? message.slice(prefixMatch[0].length) : message;

      return { hash, message, prefix, subject };
    });
  } catch {
    return [];
  }
}

function groupByPrefix(commits) {
  const groups = {};
  for (const c of commits) {
    if (!groups[c.prefix]) groups[c.prefix] = [];
    groups[c.prefix].push(c);
  }
  return groups;
}

// ---------------------------------------------------------------------------
// Skill generation
// ---------------------------------------------------------------------------

function generateManifest(name, groups) {
  const triggerHints = [];
  if (groups.feat) triggerHints.push('new feature implementation');
  if (groups.fix) triggerHints.push('bug fixing');
  if (groups.refactor) triggerHints.push('code refactoring');
  if (groups.test) triggerHints.push('test writing');
  if (groups.docs) triggerHints.push('documentation updates');

  const files = [`${name}-patterns.md`];

  return [
    `# ${titleCase(name)} Skill`,
    '',
    '## Name',
    titleCase(name),
    '',
    '## Description',
    `Patterns extracted from recent git history for ${name}. Auto-generated by skill-creator.`,
    '',
    '## Trigger Conditions',
    ...triggerHints.map((h) => `- ${h}`),
    triggerHints.length === 0 ? '- General development tasks' : '',
    '',
    '## Files',
    ...files.map((f) => `- \`${f}\` â€” Extracted patterns and examples`),
    '',
    '## Model Recommendation',
    '- **Sonnet** for applying patterns during implementation',
    '',
  ]
    .filter((line) => line !== '')
    .join('\n') + '\n';
}

function generatePatternsFile(name, groups) {
  const lines = [`# ${titleCase(name)} Patterns`, ''];

  for (const [prefix, commits] of Object.entries(groups)) {
    lines.push(`## ${titleCase(prefix)} Patterns`, '');
    lines.push(`Extracted from ${commits.length} commits:`, '');

    for (const c of commits.slice(0, 10)) {
      lines.push(`- ${c.subject} (\`${c.hash}\`)`);
    }
    if (commits.length > 10) {
      lines.push(`- ... and ${commits.length - 10} more`);
    }

    lines.push('', '### Suggested Pattern', '');
    lines.push('```');
    lines.push('TODO: Document the reusable pattern identified from these commits.');
    lines.push('Include: context, problem, solution, example code, anti-patterns.');
    lines.push('```');
    lines.push('');
  }

  lines.push('## Checklist');
  lines.push('- [ ] Review auto-extracted patterns for accuracy');
  lines.push('- [ ] Add concrete code examples');
  lines.push('- [ ] Remove irrelevant commits');
  lines.push('- [ ] Validate trigger conditions in SKILL.md');
  lines.push('');

  return lines.join('\n');
}

function titleCase(str) {
  return str
    .split('-')
    .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
    .join(' ');
}

// ---------------------------------------------------------------------------
// Main: createSkill
// ---------------------------------------------------------------------------

function createSkill(name, range, outputBase) {
  // Validate name
  if (!name) {
    log('error', 'Skill name is required. Usage: node skill-creator.js <name>');
    return false;
  }
  if (!VALID_NAME_RE.test(name)) {
    log('error', `Invalid skill name "${name}". Use lowercase alphanumeric with hyphens (e.g., "my-skill").`);
    return false;
  }

  const root = getProjectRoot() || process.cwd();
  const skillDir = path.resolve(root, outputBase, name);

  if (fileExists(skillDir)) {
    log('error', `Skill directory already exists: ${skillDir}`);
    return false;
  }

  // Parse git log
  log('info', `Parsing git log for range: ${range}`);
  const commits = parseGitLog(range);

  if (commits.length === 0) {
    log('warn', 'No commits found in the specified range. Creating skill with empty patterns.');
  }

  const groups = groupByPrefix(commits);

  // Generate files
  const manifestContent = generateManifest(name, groups);
  const patternsContent = generatePatternsFile(name, groups);

  // Write files
  const manifestPath = path.join(skillDir, 'SKILL.md');
  const patternsPath = path.join(skillDir, `${name}-patterns.md`);

  writeFile(manifestPath, manifestContent);
  writeFile(patternsPath, patternsContent);

  log('success', `Skill "${name}" created at ${skillDir}`);
  log('info', `  - ${manifestPath}`);
  log('info', `  - ${patternsPath}`);
  log('info', '');
  log('info', 'Next steps:');
  log('info', '  1. Review SKILL.md and update trigger conditions');
  log('info', '  2. Fill in pattern details in the patterns file');
  log('info', '  3. Run: node scripts/validate-skills.js');

  return true;
}

// ---------------------------------------------------------------------------
// Entry point
// ---------------------------------------------------------------------------

if (require.main === module) {
  const opts = parseArgs(process.argv);
  const success = createSkill(opts.name, opts.range, opts.output);
  process.exit(success ? 0 : 1);
}

module.exports = { createSkill, parseGitLog, generateManifest, groupByPrefix, titleCase };
